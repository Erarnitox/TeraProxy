<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Article.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="mmo-hacking-bootcamp"><a name="mmo-hacking-bootcamp" href="#mmo-hacking-bootcamp"></a>MMO Hacking Bootcamp</h1><p>Hello and welcome to my first real guide or tutorial on this Forum.<br>Since i got inspired by this talk: <a href="https://youtu.be/QOfroRgBgo0">https://youtu.be/QOfroRgBgo0</a><br>recently i decided to give that a try myself.<br>I hope you find this guide useful and also enjoy reading it.<br>Please feel free to give feedback on this guide and on the code as well.<br>So let’s get started :)</p><h2 id="introduction"><a name="introduction" href="#introduction"></a>Introduction</h2><p>In MMO hacking there are as always different approches.<br>Our goal however is not to write a bot for the game or something like that.</p><p>We are trying to find exploits in the protocol of the game.<br>For that we want to do Man in the middle attacks so we can fuzz by crafting our own packets.<br>To be able to do that we will create our tools in the first part of this guide.<br>After that we try to understand the protocol and identify possible vulns.</p><p>For this guide i have taken the game Tera as an example but everything in this guide<br>does also apply to any other MMO.</p><p><img src="tera.jpg" alt="Tera Logo"></p><p>If you don’t understand everything quite yet:<br>Don’t worry this is a step by step guide.<br>Meaning I will take you by the hand :)</p><h2 id="recon"><a name="recon" href="#recon"></a>Recon</h2><p>First of all you always want to do some recon on the game first before jumping right into hacking it.<br>That includes finding out which engine/language was used o create the game, which frameworks, which anticheat<br>gets used (if any) etc.<br>Also search for previous work done on the game that can save a lot of debugging and re work.<br>Im sure you all know how to do that.<br>However here hare some little tricks you might find useful to fill this section with at least some infromation :)</p><ul>
<li>You can use Process Hacker to view the command line arguments which where used to start the game.<br>This can be helpful when you want to start the game without the launcher.<br>(ProcessHacker: <a href="https://processhacker.sourceforge.io/">https://processhacker.sourceforge.io/</a>)</li><li>You can use Process Monitor to see all traffic a process is sending and recieving.<br>That can give you a first insight and also let’s you know whether the packets are encrypted at all.<br>Most of the time the packets will be encrypted.<br>(Process Monitor: <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">https://docs.microsoft.com/en-us/sysinternals/downloads/procmon</a>)</li></ul><h2 id="tool-creation"><a name="tool-creation" href="#tool-creation"></a>Tool creation</h2><p>As you have seen in our Recon phase we are lucky and dont have to deal with any anti cheat technologie.<br>And that is common in MMOs.<br>However they prevent tinkering with the game by different means.<br>Sent and recieved packets are always encrypted and they do also encrypt data in memory pretty often to prevent the usual memory editing (with cheatengine for example).</p><p>So How do we get around that?:<br>We will hook the packet creation process in an early stage where we can read the raw unencrypted data of the packets.</p><p>For that we have to find the internal/ high level send function the game uses to send packets itself and hook there.</p><p>As Mamda has saied his guide this can be a tadious process so i will cover this step in great detail and try to provide you with as much detail as i can.</p><h3 id="finding-the-internal-/-high-level-send-function"><a name="finding-the-internal-/-high-level-send-function" href="#finding-the-internal-/-high-level-send-function"></a>Finding the Internal / High level Send function</h3><p>Communication between server and client always happens either through TCP or UDP packets.<br>In theory there can be a list of functions used for sending and recieving these packets.<br>(Mamda has listed most of these in his packet guide)<br>But unless your game is very exotic or old your game will most likely use the ws2_32.dll for networking and make use of either the send() function or the WSASend() function for sending packets.<br>However if your game sends packets over udp instead of tcp it will most likely use the sendto() equivalents.<br>For Recieving Data either recv() or WSARecv() are used.<br>I wont cover hooking/finding the recv() function in this guide.</p><p>After all that saied let’s get started.<br>So our first problem is: finding out which functionis used by our game.<br>This is relatively easy to do in cheat engine or any other debugger.<br>We just a breakpoint at the send() function and see if its get hit.</p><p>So let’s go through this step by step.<br>1) attach cheat engine to our game:<br><img src="attach.gif" alt="attach"><br>2) find the send function:<br>to locate the send function we have to open the Memory View in cheat engine.<br>In the View Menu we can enumerate all loaded dlls.<br><img src="enum.gif" alt="enum"><br>From here we can search for the ws2_32.dll and its send() function.<br>If we double click the function cheat engine will take us there.<br><img src="send.gif" alt="send"><br>3) set a breakpoint at the send function:<br>To find out whether our function gets called by the game at all we need to set a breakpoint at the send() function. It should get triggered every time we do something in game.<br><img src="setbreak.gif" alt="setbreak"><br>If your breakpoint gets hit and the games execution stops once we do something in game -&gt; great.<br>If not -&gt; you have to repeat the last step with a different send function and see if that one gets called.<br>4) finding the internal send:<br>This is one of the harder parts in this guide but i wiill try my best to guide you through even if your game is different.<br>At first it’s important to understand the send function our game is using.<br>For that alwas search at MSDN for the used send function.<br>In my case send():<br><img src="msdnsend.gif" alt="msdnsend"><br>(<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send">https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send</a>)<br>as we can see the 2nd parameter is a char* to our encrypted buffer and the 3rd is the length of our buffer.<br>These are the most important for us.<br><img src="callstack.jpg" alt="callstack"><br>As you can see with our breakpoint hit we can inspect the current stack.<br>The first address on the stack (the one pushed onto the stack) will always be the return address (where the function got called from). After that we can see the srguments the function expects pushed onto the stack.<br>I have marked the ones that are important for us.<br>Now we have multiple options to go from here to find our internal send function.<br>One would be to double klick the return address to get to where the send() function got called from and repeat that until we can find the send function the game uses itself (before the packets get encrypted).<br>The other way i will use is to add the address of the encrypted buffer to cheat engines address table<br>and then -&gt; find out what writes to this address.<br><img src="whatwrites.gif" alt="whatwrites"><br>This will only work if the address of the encrypted buffer doesnt change too often.<br>But it has the charm that we can will find the end of the encryption function most of the time straigt away.<br>After that we just have to trace back again by placing a breakpoint at the encrypt function to see the return address on the stack there. If we double click there to see where it got called from and repeat that process maybe some layers upwards we can find our internal send function pretty quick.<br>Most of the time its the best to use a mixture of both methods depending on what your game is doing to reach your goal “quickly”. What i did to find the send function for this game was to first tracke back where the send function got called from and followed the buffer. As i saw the buffer gets passed to the function that calles send as an argument i added that buffer to the address list and had a look for what writes to it.<br>It appears that tera uses a wrapper around the send() function thats just there to call send() really.<br>However this procedure is different for every game and it’s important that you understand basic revrsing and debugging for you find your send function successfully.<br>There can be a lot of places that write to the buffer and you might have to do multiple hooks.<br>However if there is a unified send function in the game it has to write to the buffer at least once for every action you take. So you can ignore the opcodes that only write to the buffer for certain actions most times.<br>It’s still a good idea to note down the addresses of these opcodes as well so you can still check them out later.</p><p>(I greatly enjoyed the workshop at begin.re it mostly covers static analysis. But im sure if you struggle to understand what the game is doing this workshop will help you to get to the next level :))</p><p>After you have spent some time reversing the game and tracing functions back you will most likely have found the internal send function (or given up).<br>Here is the one i found for Tera:<br><img src="internalsend.jpg" alt="internalsend"><br>As we can see on the stack this function takes a pointer to the buffer and it’s length as argument.<br>This will be helpful to know later.</p><h3 id="hooking-the-send-function"><a name="hooking-the-send-function" href="#hooking-the-send-function"></a>Hooking the send function</h3><p>we now have some options we could modify the packet with the hook itself or just log it and call the send function ourself later.<br>Since i aimed at a packet editor like the one Mafred uses i decided to go with the 2nd option.<br>So we just need to acess the packet buffer and it’s length through our hook so we can log the packet.<br>i wont cover how to do hooking since this was covered here: <a href="https://guidedhacking.com/threads/code-detouring-hooking-guide.14185/">https://guidedhacking.com/threads/code-detouring-hooking-guide.14185/</a><br>but i will explain what i do in my hook.<br>First lets have a quick look:</p><pre><code data-origin="<pre><code>    void* teax;
    void* tebx;
    void* tecx;
    void* tedx;
    void* tesi;
    void* tedi;
    void* tebp;
    void* tesp;

    DWORD sentLen;
    char* sentBuffer;

    void __declspec(naked) sendHookFunc() {
    __asm {
        mov teax, eax; backup
        mov tebx, ebx
        mov tecx, ecx
        mov tedx, edx
        mov tesi, esi
        mov tedi, edi
        mov tebp, ebp
        mov tesp, esp
        mov eax, [esp + 0x8]
        mov sentBuffer, eax
        mov eax, [esp + 0xC]
        mov sentLen, eax
    }
    printSendBufferToLog();
    __asm{
        mov eax, teax
        mov ebx, tebx
        mov ecx, tecx
        mov edx, tedx
        mov esi, tesi
        mov edi, tedi
        mov ebp, tebp
        mov esp, tesp; end of restore
        mov ebp, esp
        push ebx
        mov ebx, ecx
        jmp[jmpBackAddrSend]
    }
}
</code></pre>">    void* teax;
    void* tebx;
    void* tecx;
    void* tedx;
    void* tesi;
    void* tedi;
    void* tebp;
    void* tesp;

    DWORD sentLen;
    char* sentBuffer;

    void __declspec(naked) sendHookFunc() {
    __asm {
        mov teax, eax; backup
        mov tebx, ebx
        mov tecx, ecx
        mov tedx, edx
        mov tesi, esi
        mov tedi, edi
        mov tebp, ebp
        mov tesp, esp
        mov eax, [esp + 0x8]
        mov sentBuffer, eax
        mov eax, [esp + 0xC]
        mov sentLen, eax
    }
    printSendBufferToLog();
    __asm{
        mov eax, teax
        mov ebx, tebx
        mov ecx, tecx
        mov edx, tedx
        mov esi, tesi
        mov edi, tedi
        mov ebp, tebp
        mov esp, tesp; end of restore
        mov ebp, esp
        push ebx
        mov ebx, ecx
        jmp[jmpBackAddrSend]
    }
}
</code></pre><p>first we have some backup variables to back up the registers.<br>You could just push them to the stack and pop them back later but it’s safer to do it this way since we have no direct control over what the compiler pushes to the stack etc.<br>So i decided to just store the values of the registers in variables.<br>It’s important to do that if we are panning to call c++ function from within our hook since they will most likely change the registers and we dont want them to have changed at the end of our hook since that can influence the following code gets executed. Thats why we restore them just before we execute the opcodes that we overwrote with our hook.<br>esp is the stack pointer through that pointer we can access values that go pushed to the stack.<br>That means esp -&gt; first element on the stack, esp +0x4 -&gt; 2nd element, esp + 0x08 -&gt; 3rd …</p><h3 id="calling-the-send-function"><a name="calling-the-send-function" href="#calling-the-send-function"></a>Calling the send function</h3><p>To call any function we need to follow the calling convetion the function likes to be called by.<br>(More on calling convetions: <a href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2019">https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2019</a>)<br>However we can make it easy for ourselfs and dont worry too much about this since most games use the <code>__thiscall</code><br>calling convetion for the send function since this convetion is used for any function that is part of a class.<br>(So this calling convetion is used for every method!).<br>To call a function like this we first need to get the pointer to the class it belongs to.<br><img src="thiscall.jpg" alt="thiscall"><br>As we can see we can get the this pointer from the ECX register.<br>The easiest way to get ourself a copy of that pointer is just to add this to our hook:</p><pre><code data-origin="<pre><code>void* thisPTR;

//this goes inside our asm block:
mov thisPTR, ecx
</code></pre>">void* thisPTR;

//this goes inside our asm block:
mov thisPTR, ecx
</code></pre><p>Since we already figured out the arguments the function takes we can now define the type of the function.<br>And since we already know the location of the function we can initialize a variable of that type with that location:</p><pre><code data-origin="<pre><code>typedef void (__thiscall* InternalSend)(void* thisClass, const char* data, DWORD length);
InternalSend Send = (InternalSend)0x1445270;
</code></pre>">typedef void (__thiscall* InternalSend)(void* thisClass, const char* data, DWORD length);
InternalSend Send = (InternalSend)0x1445270;
</code></pre><p>(more on function pointers: <a href="https://www.learncpp.com/cpp-tutorial/78-function-pointers/">https://www.learncpp.com/cpp-tutorial/78-function-pointers/</a>)</p><p>After that we can use this Send function like any other function in our code and sould be able to send packets to the server ourselves.</p><p>with the finished packet editor this looks like this:<br><img src="replay.gif" alt="replay"></p><h3 id="writing-the-packet-editor-dll"><a name="writing-the-packet-editor-dll" href="#writing-the-packet-editor-dll"></a>writing the Packet Editor DLL</h3><p>Now we finally have enough information to write the packet editor.<br>We for now only have the static address of the send function but MMOs tend to patch regularely.<br>That means this way we might have to find the send sunction every patch.<br>To avoid that problem i decided to use pattern scanning to find the send function.<br>For that i have used Rakes tutorial and code.<br>(Pattern Scan Tutorial: <a href="https://guidedhacking.com/threads/external-internal-pattern-scanning-guide.14112/">https://guidedhacking.com/threads/external-internal-pattern-scanning-guide.14112/</a>)</p><h4 id="scan.h"><a name="scan.h" href="#scan.h"></a>Scan.h</h4><pre><code data-origin="<pre><code>#pragma once
//Tanks to rake for this code here and Nomade for making it more stable
char* ScanBasic(const char* pattern, const char* mask, char* begin, size_t size){
    size_t patternLen = strlen(mask);
    for (size_t i = 0; i &amp;lt; size; i++){
        bool found = true;
        for (size_t j = 0; j &amp;lt; patternLen; j++){
            if (mask[j] != '?' &amp;amp;&amp;amp; pattern[j] != *(char*)((intptr_t)begin + i + j)){
                found = false;
                break;
            }
        }
        if (found){
            return (begin + i);
        }
    }
    return nullptr;
}

char* ScanInternal(const char* pattern, const char* mask, char* begin, size_t size){
    char* match{ nullptr };
    MEMORY_BASIC_INFORMATION mbi{};

    for (char* curr = begin; curr &amp;lt; begin + size; curr += mbi.RegionSize){
        if (!VirtualQuery(curr, &amp;amp;mbi, sizeof(mbi)) || mbi.State != MEM_COMMIT || mbi.Protect == PAGE_NOACCESS) continue;
        match = ScanBasic(pattern, mask, curr, mbi.RegionSize);

        if (match != nullptr &amp;amp;&amp;amp; match != pattern){
            break;
        }
    }
    return match;
}
</code></pre>">#pragma once
//Tanks to rake for this code here and Nomade for making it more stable
char* ScanBasic(const char* pattern, const char* mask, char* begin, size_t size){
    size_t patternLen = strlen(mask);
    for (size_t i = 0; i &lt; size; i++){
        bool found = true;
        for (size_t j = 0; j &lt; patternLen; j++){
            if (mask[j] != '?' &amp;&amp; pattern[j] != *(char*)((intptr_t)begin + i + j)){
                found = false;
                break;
            }
        }
        if (found){
            return (begin + i);
        }
    }
    return nullptr;
}

char* ScanInternal(const char* pattern, const char* mask, char* begin, size_t size){
    char* match{ nullptr };
    MEMORY_BASIC_INFORMATION mbi{};

    for (char* curr = begin; curr &lt; begin + size; curr += mbi.RegionSize){
        if (!VirtualQuery(curr, &amp;mbi, sizeof(mbi)) || mbi.State != MEM_COMMIT || mbi.Protect == PAGE_NOACCESS) continue;
        match = ScanBasic(pattern, mask, curr, mbi.RegionSize);

        if (match != nullptr &amp;&amp; match != pattern){
            break;
        }
    }
    return match;
}
</code></pre><p>For the hooking i wrote a simple class that cleans up after itself so we can load and unload the dll without crashing the game.</p><h4 id="hook.h"><a name="hook.h" href="#hook.h"></a>Hook.h</h4><pre><code data-origin="<pre><code>#pragma once
class Hook {
    void* tToHook;
    char* oldOpcodes;
    int tLen;
public:
    Hook(void* toHook, void* ourFunct, int len) : tToHook(toHook), oldOpcodes(nullptr), tLen(len){
        if (len &amp;lt; 5) {
            return;
        }

        DWORD curProtection;
        VirtualProtect(toHook, len, PAGE_EXECUTE_READWRITE, &amp;amp;curProtection);

        oldOpcodes = (char*)malloc(len);
        if (oldOpcodes != nullptr) {
            for (int i = 0; i &amp;lt; len; ++i) {
                oldOpcodes[i] = ((char*)toHook)[i];
            }
        }

        memset(toHook, 0x90, len);

        DWORD relativeAddress = ((DWORD)ourFunct - (DWORD)toHook) - 5;

        *(BYTE*)toHook = 0xE9;
        *(DWORD*)((DWORD)toHook + 1) = relativeAddress;

        VirtualProtect(toHook, len, curProtection, &amp;amp;curProtection);
    }

    ~Hook() {
        if (oldOpcodes != nullptr) {
            DWORD curProtection;
            VirtualProtect(tToHook, tLen, PAGE_EXECUTE_READWRITE, &amp;amp;curProtection);
            for (int i = 0; i &amp;lt; tLen; ++i) {
                ((char*)tToHook)[i] = oldOpcodes[i];
            }
            VirtualProtect(tToHook, tLen, curProtection, &amp;amp;curProtection);
            free(oldOpcodes);
        }
    }
};
</code></pre>">#pragma once
class Hook {
    void* tToHook;
    char* oldOpcodes;
    int tLen;
public:
    Hook(void* toHook, void* ourFunct, int len) : tToHook(toHook), oldOpcodes(nullptr), tLen(len){
        if (len &lt; 5) {
            return;
        }

        DWORD curProtection;
        VirtualProtect(toHook, len, PAGE_EXECUTE_READWRITE, &amp;curProtection);

        oldOpcodes = (char*)malloc(len);
        if (oldOpcodes != nullptr) {
            for (int i = 0; i &lt; len; ++i) {
                oldOpcodes[i] = ((char*)toHook)[i];
            }
        }

        memset(toHook, 0x90, len);

        DWORD relativeAddress = ((DWORD)ourFunct - (DWORD)toHook) - 5;

        *(BYTE*)toHook = 0xE9;
        *(DWORD*)((DWORD)toHook + 1) = relativeAddress;

        VirtualProtect(toHook, len, curProtection, &amp;curProtection);
    }

    ~Hook() {
        if (oldOpcodes != nullptr) {
            DWORD curProtection;
            VirtualProtect(tToHook, tLen, PAGE_EXECUTE_READWRITE, &amp;curProtection);
            for (int i = 0; i &lt; tLen; ++i) {
                ((char*)tToHook)[i] = oldOpcodes[i];
            }
            VirtualProtect(tToHook, tLen, curProtection, &amp;curProtection);
            free(oldOpcodes);
        }
    }
};
</code></pre><p>Everything game specific i have handeled in another header file.<br>It especially takes care of holding pointers to the send function and holds the code we execute in our hook:</p><h4 id="tera.h"><a name="tera.h" href="#tera.h"></a>Tera.h</h4><pre><code data-origin="<pre><code>#pragma once
typedef void (__thiscall* InternalSend)(void* thisClass, const char* data, DWORD length);
InternalSend Send;
void* thisPTR;
wchar_t moduleName[] = L&quot;TERA.exe&quot;;
size_t toHookSend = 1;
int sendHookLen = 5;
DWORD sentLen;
char* sentBuffer;
char* tmpBuffer;

const char* internalSendPattern = &quot;\x55\x8B\xEC\x53\x8B\xD9\x83\x7B\x0C\x00\x74\x54\x8B\x8B\x1C\x00\x02\x00\x85\xC9\x74\x2E\x8B\x01\x8B\x01\x8B\x40\x18\xFF\xD0&quot;;
const char* internalSendMask = &quot;xxxxxxxxxx??xx????xxxxxxx&quot;;

bool logSentHook = false;

void* teax;
void* tebx;
void* tecx;
void* tedx;
void* tesi;
void* tedi;
void* tebp;
void* tesp;

void printSendBufferToLog();

DWORD jmpBackAddrSend;
void __declspec(naked) sendHookFunc() {
    __asm {
        mov thisPTR, ecx
        mov teax, eax; backup
        mov tebx, ebx
        mov tecx, ecx
        mov tedx, edx
        mov tesi, esi
        mov tedi, edi
        mov tebp, ebp
        mov tesp, esp
        mov eax, [esp + 0x8]
        mov sentBuffer, eax
        mov eax, [esp + 0xC]
        mov sentLen, eax
    }
    if (logSentHook) {
        printSendBufferToLog();
    }
    __asm{
        mov eax, teax
        mov ebx, tebx
        mov ecx, tecx
        mov edx, tedx
        mov esi, tesi
        mov edi, tedi
        mov ebp, tebp
        mov esp, tesp; end of restore
        mov ebp, esp
        push ebx
        mov ebx, ecx
        jmp[jmpBackAddrSend]
    }
}
</code></pre>">#pragma once
typedef void (__thiscall* InternalSend)(void* thisClass, const char* data, DWORD length);
InternalSend Send;
void* thisPTR;
wchar_t moduleName[] = L"TERA.exe";
size_t toHookSend = 1;
int sendHookLen = 5;
DWORD sentLen;
char* sentBuffer;
char* tmpBuffer;

const char* internalSendPattern = "\x55\x8B\xEC\x53\x8B\xD9\x83\x7B\x0C\x00\x74\x54\x8B\x8B\x1C\x00\x02\x00\x85\xC9\x74\x2E\x8B\x01\x8B\x01\x8B\x40\x18\xFF\xD0";
const char* internalSendMask = "xxxxxxxxxx??xx????xxxxxxx";

bool logSentHook = false;

void* teax;
void* tebx;
void* tecx;
void* tedx;
void* tesi;
void* tedi;
void* tebp;
void* tesp;

void printSendBufferToLog();

DWORD jmpBackAddrSend;
void __declspec(naked) sendHookFunc() {
    __asm {
        mov thisPTR, ecx
        mov teax, eax; backup
        mov tebx, ebx
        mov tecx, ecx
        mov tedx, edx
        mov tesi, esi
        mov tedi, edi
        mov tebp, ebp
        mov tesp, esp
        mov eax, [esp + 0x8]
        mov sentBuffer, eax
        mov eax, [esp + 0xC]
        mov sentLen, eax
    }
    if (logSentHook) {
        printSendBufferToLog();
    }
    __asm{
        mov eax, teax
        mov ebx, tebx
        mov ecx, tecx
        mov edx, tedx
        mov esi, tesi
        mov edi, tedi
        mov ebp, tebp
        mov esp, tesp; end of restore
        mov ebp, esp
        push ebx
        mov ebx, ecx
        jmp[jmpBackAddrSend]
    }
}
</code></pre><p>And lastly we have have the main dll. This file holds the entry point to our dll, spins up the GUI of our packet editor (using the WinApi) and so on. This file holds the main logic for our editor.</p><h4 id="dllmain.cpp"><a name="dllmain.cpp" href="#dllmain.cpp"></a>dllmain.cpp</h4><pre><code data-origin="<pre><code>#include &quot;pch.h&quot;
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iomanip&amp;gt;
#include &quot;Tera.h&quot;
#include &quot;Hook.h&quot;
#include &quot;Scan.h&quot;
#include &amp;lt;vector&amp;gt;

#define MYMENU_EXIT (WM_APP + 100)
#define SEND_BUTTON (WM_APP + 101)
#define LOG_SEND (WM_APP + 102)
#define CLEAR_BUTTON (WM_APP + 104)

HMODULE inj_hModule;
HWND hCraftedPacket;
HWND hLog;

BOOL LogSend = 0;
BOOL LogRecv = 0;

HWND hLogSend;
HWND hLogRecv;

wchar_t craftedBuffer[533];
char bufferToSend[533];
char const hex_chars[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

uintptr_t moduleBase;
std::vector&amp;lt;char&amp;gt; logText;

HMENU CreateDLLWindowMenu(){
    HMENU hMenu;
    hMenu = CreateMenu();
    HMENU hMenuPopup;
    if (hMenu == NULL)
        return FALSE;
    hMenuPopup = CreatePopupMenu();
    AppendMenuW(hMenuPopup, MF_STRING, MYMENU_EXIT, TEXT(&quot;Exit&quot;));
    AppendMenuW(hMenu, MF_POPUP, (UINT_PTR)hMenuPopup, TEXT(&quot;File&quot;));
    return hMenu;
}

LRESULT CALLBACK MessageHandler(HWND hWindow, UINT uMessage, WPARAM wParam, LPARAM lParam) {
    switch (uMessage) {
    case WM_CLOSE:
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case MYMENU_EXIT:
            PostQuitMessage(0);
            return 0;
            break;
        case SEND_BUTTON:
            GetWindowText(hCraftedPacket, craftedBuffer, 533);
            size_t len;
            wcstombs_s(&amp;amp;len, bufferToSend, 533, craftedBuffer, 533);
            size_t i;
            i = 0;
            for (size_t count = 0; count &amp;lt; len; ++i, count += 3) {
                if (bufferToSend[count] &amp;gt;= 'A') {
                    bufferToSend[count] -= 'A';
                    bufferToSend[count] += 10;
                }
                else {
                    bufferToSend[count] -= 48;
                }

                if (bufferToSend[count+1] &amp;gt;= 'A') {
                    bufferToSend[count+1] -= 'A';
                    bufferToSend[count+1] += 10;
                }
                else {
                    bufferToSend[count+1] -= 48;
                }

                bufferToSend[i] = (__int8)(((char)bufferToSend[count]) * (char)16);
                bufferToSend[i] += (__int8)bufferToSend[count + 1];
            }
            bufferToSend[i] = '\0';
            if (thisPTR != 0) {
                Send(thisPTR, bufferToSend, i);
            }
            break;
        case LOG_SEND:
            LogSend = IsDlgButtonChecked(hWindow, LOG_SEND);

            if (LogSend == BST_CHECKED) {
                CheckDlgButton(hWindow, LOG_SEND, BST_UNCHECKED);
                logSentHook = false;
            }
            else {
                CheckDlgButton(hWindow, LOG_SEND, BST_CHECKED);
                logSentHook = true;
            }
            break;
        case CLEAR_BUTTON:
            logText.erase(logText.begin(), logText.end());
            SetWindowTextA(hLog, &quot;Cleared! :)\r\nFind Tutorials on Guidedhacking.com!&quot;);
        }
    }
    return DefWindowProc(hWindow, uMessage, wParam, lParam);
}

//Register our windows Class
BOOL RegisterDLLWindowClass(const wchar_t szClassName[]) {
    WNDCLASSEX wc;
    wc.hInstance = inj_hModule;
    wc.lpszClassName = (LPCWSTR)szClassName;
    wc.lpfnWndProc = MessageHandler;
    wc.style = CS_VREDRAW | CS_HREDRAW;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hIcon = LoadIcon(NULL, IDI_SHIELD);
    wc.hIconSm = LoadIcon(NULL, IDI_SHIELD);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszMenuName = NULL;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);
    if (!RegisterClassEx(&amp;amp;wc))
        return 0;
    return 1;
}

inline void printSendBufferToLog() {
    char sendID[] = &quot;[SEND] &quot;;

    while (logText.size() &amp;gt; 4096) {
        logText.erase(logText.begin(), logText.begin() + 400);
    }
    if (logText.size() &amp;gt; 1) {
        logText.pop_back();
        logText.push_back('\r');
        logText.push_back('\n');
    }

    for (DWORD i = 0; i &amp;lt; sentLen + 7; ++i) {
        if (i &amp;lt; 7) {
            logText.push_back(sendID[i]);
        }
        else {
            logText.push_back(hex_chars[((sentBuffer)[i - 7] &amp;amp; 0xF0) &amp;gt;&amp;gt; 4]);
            logText.push_back(hex_chars[((sentBuffer)[i - 7] &amp;amp; 0x0F) &amp;gt;&amp;gt; 0]);
            logText.push_back(' ');
        }
    }
    logText.push_back('\0');
    SetWindowTextA(hLog, &amp;amp;logText[0]);
}

DWORD WINAPI WindowThread(HMODULE hModule){
    logText = std::vector&amp;lt;char&amp;gt;();
    moduleBase = (uintptr_t)GetModuleHandle(moduleName);
    Send = (InternalSend)(ScanInternal(internalSendPattern, internalSendMask, (char*)(moduleBase+ 0x0500000), 0x3000000));
    toHookSend += (size_t)Send;
    jmpBackAddrSend = toHookSend + sendHookLen;

    Hook* sendHook = new Hook((void*)toHookSend, (void*)sendHookFunc, sendHookLen);

    MSG messages;
    HMENU hMenu = CreateDLLWindowMenu();
    HWND hSendButton;
    HWND hClearButton;

    RegisterDLLWindowClass(L&quot;InjectedDLLWindowClass&quot;);
    HWND hwnd = CreateWindowEx(0, L&quot;InjectedDLLWindowClass&quot;, L&quot;Erarnitox's Tera Proxy | GuidedHacking.com&quot;, WS_EX_LAYERED, CW_USEDEFAULT, CW_USEDEFAULT, 1020, 885, NULL, hMenu, inj_hModule, NULL);
    hLog = CreateWindowEx(0, L&quot;edit&quot;, L&quot;Tera Proxy made by Erarnitox\r\n!!! visit GuidedHacking.com !!!&quot;, WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | WS_BORDER | ES_READONLY, 5, 5, 1005, 700, hwnd, NULL, hModule, NULL);

    hClearButton = CreateWindowEx(0, L&quot;button&quot;, L&quot;Clear Log&quot;, WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_BORDER | BS_DEFPUSHBUTTON, 5, 710, 100, 30, hwnd, (HMENU)CLEAR_BUTTON, hModule, NULL);
    hSendButton = CreateWindowEx(0, L&quot;button&quot;, L&quot;Send&quot;, WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_BORDER | BS_DEFPUSHBUTTON, 5, 800, 100, 30, hwnd, (HMENU)SEND_BUTTON, hModule, NULL);
    hCraftedPacket = CreateWindowEx(0, L&quot;edit&quot;, L&quot;&amp;lt;Packet Data&amp;gt;&quot;, WS_TABSTOP | WS_VISIBLE | WS_CHILD | ES_MULTILINE | WS_BORDER, 110, 730, 900, 100, hwnd, NULL, hModule, NULL);

    hLogSend = CreateWindowEx(0, L&quot;button&quot;, L&quot;Log Send&quot;, WS_CHILD | WS_VISIBLE | BS_CHECKBOX, 110, 705, 100, 25, hwnd, (HMENU)LOG_SEND, hModule, NULL);

    ShowWindow(hwnd, SW_SHOWNORMAL);

    while (GetMessage(&amp;amp;messages, NULL, 0, 0)){
        if (GetAsyncKeyState(VK_END) &amp;amp; 1) {
            break;
        }
        TranslateMessage(&amp;amp;messages);
        DispatchMessage(&amp;amp;messages);
    }

    //exit:
    delete sendHook;
    FreeLibraryAndExitThread(hModule, 0);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved){
    switch (ul_reason_for_call){
        case DLL_PROCESS_ATTACH:
            inj_hModule = hModule; 
            HANDLE ThreadHandle = CreateThread(0, NULL, (LPTHREAD_START_ROUTINE)WindowThread, hModule, NULL, NULL);

            if (ThreadHandle != NULL) {
                CloseHandle(ThreadHandle);
            }
        break;
    }
    return TRUE;
}
</code></pre>">#include "pch.h"
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include "Tera.h"
#include "Hook.h"
#include "Scan.h"
#include &lt;vector&gt;

#define MYMENU_EXIT (WM_APP + 100)
#define SEND_BUTTON (WM_APP + 101)
#define LOG_SEND (WM_APP + 102)
#define CLEAR_BUTTON (WM_APP + 104)

HMODULE inj_hModule;
HWND hCraftedPacket;
HWND hLog;

BOOL LogSend = 0;
BOOL LogRecv = 0;

HWND hLogSend;
HWND hLogRecv;

wchar_t craftedBuffer[533];
char bufferToSend[533];
char const hex_chars[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

uintptr_t moduleBase;
std::vector&lt;char&gt; logText;

HMENU CreateDLLWindowMenu(){
    HMENU hMenu;
    hMenu = CreateMenu();
    HMENU hMenuPopup;
    if (hMenu == NULL)
        return FALSE;
    hMenuPopup = CreatePopupMenu();
    AppendMenuW(hMenuPopup, MF_STRING, MYMENU_EXIT, TEXT("Exit"));
    AppendMenuW(hMenu, MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("File"));
    return hMenu;
}

LRESULT CALLBACK MessageHandler(HWND hWindow, UINT uMessage, WPARAM wParam, LPARAM lParam) {
    switch (uMessage) {
    case WM_CLOSE:
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case MYMENU_EXIT:
            PostQuitMessage(0);
            return 0;
            break;
        case SEND_BUTTON:
            GetWindowText(hCraftedPacket, craftedBuffer, 533);
            size_t len;
            wcstombs_s(&amp;len, bufferToSend, 533, craftedBuffer, 533);
            size_t i;
            i = 0;
            for (size_t count = 0; count &lt; len; ++i, count += 3) {
                if (bufferToSend[count] &gt;= 'A') {
                    bufferToSend[count] -= 'A';
                    bufferToSend[count] += 10;
                }
                else {
                    bufferToSend[count] -= 48;
                }

                if (bufferToSend[count+1] &gt;= 'A') {
                    bufferToSend[count+1] -= 'A';
                    bufferToSend[count+1] += 10;
                }
                else {
                    bufferToSend[count+1] -= 48;
                }

                bufferToSend[i] = (__int8)(((char)bufferToSend[count]) * (char)16);
                bufferToSend[i] += (__int8)bufferToSend[count + 1];
            }
            bufferToSend[i] = '\0';
            if (thisPTR != 0) {
                Send(thisPTR, bufferToSend, i);
            }
            break;
        case LOG_SEND:
            LogSend = IsDlgButtonChecked(hWindow, LOG_SEND);

            if (LogSend == BST_CHECKED) {
                CheckDlgButton(hWindow, LOG_SEND, BST_UNCHECKED);
                logSentHook = false;
            }
            else {
                CheckDlgButton(hWindow, LOG_SEND, BST_CHECKED);
                logSentHook = true;
            }
            break;
        case CLEAR_BUTTON:
            logText.erase(logText.begin(), logText.end());
            SetWindowTextA(hLog, "Cleared! :)\r\nFind Tutorials on Guidedhacking.com!");
        }
    }
    return DefWindowProc(hWindow, uMessage, wParam, lParam);
}

//Register our windows Class
BOOL RegisterDLLWindowClass(const wchar_t szClassName[]) {
    WNDCLASSEX wc;
    wc.hInstance = inj_hModule;
    wc.lpszClassName = (LPCWSTR)szClassName;
    wc.lpfnWndProc = MessageHandler;
    wc.style = CS_VREDRAW | CS_HREDRAW;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hIcon = LoadIcon(NULL, IDI_SHIELD);
    wc.hIconSm = LoadIcon(NULL, IDI_SHIELD);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszMenuName = NULL;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);
    if (!RegisterClassEx(&amp;wc))
        return 0;
    return 1;
}

inline void printSendBufferToLog() {
    char sendID[] = "[SEND] ";

    while (logText.size() &gt; 4096) {
        logText.erase(logText.begin(), logText.begin() + 400);
    }
    if (logText.size() &gt; 1) {
        logText.pop_back();
        logText.push_back('\r');
        logText.push_back('\n');
    }

    for (DWORD i = 0; i &lt; sentLen + 7; ++i) {
        if (i &lt; 7) {
            logText.push_back(sendID[i]);
        }
        else {
            logText.push_back(hex_chars[((sentBuffer)[i - 7] &amp; 0xF0) &gt;&gt; 4]);
            logText.push_back(hex_chars[((sentBuffer)[i - 7] &amp; 0x0F) &gt;&gt; 0]);
            logText.push_back(' ');
        }
    }
    logText.push_back('\0');
    SetWindowTextA(hLog, &amp;logText[0]);
}

DWORD WINAPI WindowThread(HMODULE hModule){
    logText = std::vector&lt;char&gt;();
    moduleBase = (uintptr_t)GetModuleHandle(moduleName);
    Send = (InternalSend)(ScanInternal(internalSendPattern, internalSendMask, (char*)(moduleBase+ 0x0500000), 0x3000000));
    toHookSend += (size_t)Send;
    jmpBackAddrSend = toHookSend + sendHookLen;

    Hook* sendHook = new Hook((void*)toHookSend, (void*)sendHookFunc, sendHookLen);

    MSG messages;
    HMENU hMenu = CreateDLLWindowMenu();
    HWND hSendButton;
    HWND hClearButton;

    RegisterDLLWindowClass(L"InjectedDLLWindowClass");
    HWND hwnd = CreateWindowEx(0, L"InjectedDLLWindowClass", L"Erarnitox's Tera Proxy | GuidedHacking.com", WS_EX_LAYERED, CW_USEDEFAULT, CW_USEDEFAULT, 1020, 885, NULL, hMenu, inj_hModule, NULL);
    hLog = CreateWindowEx(0, L"edit", L"Tera Proxy made by Erarnitox\r\n!!! visit GuidedHacking.com !!!", WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | WS_BORDER | ES_READONLY, 5, 5, 1005, 700, hwnd, NULL, hModule, NULL);

    hClearButton = CreateWindowEx(0, L"button", L"Clear Log", WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_BORDER | BS_DEFPUSHBUTTON, 5, 710, 100, 30, hwnd, (HMENU)CLEAR_BUTTON, hModule, NULL);
    hSendButton = CreateWindowEx(0, L"button", L"Send", WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_BORDER | BS_DEFPUSHBUTTON, 5, 800, 100, 30, hwnd, (HMENU)SEND_BUTTON, hModule, NULL);
    hCraftedPacket = CreateWindowEx(0, L"edit", L"&lt;Packet Data&gt;", WS_TABSTOP | WS_VISIBLE | WS_CHILD | ES_MULTILINE | WS_BORDER, 110, 730, 900, 100, hwnd, NULL, hModule, NULL);

    hLogSend = CreateWindowEx(0, L"button", L"Log Send", WS_CHILD | WS_VISIBLE | BS_CHECKBOX, 110, 705, 100, 25, hwnd, (HMENU)LOG_SEND, hModule, NULL);

    ShowWindow(hwnd, SW_SHOWNORMAL);

    while (GetMessage(&amp;messages, NULL, 0, 0)){
        if (GetAsyncKeyState(VK_END) &amp; 1) {
            break;
        }
        TranslateMessage(&amp;messages);
        DispatchMessage(&amp;messages);
    }

    //exit:
    delete sendHook;
    FreeLibraryAndExitThread(hModule, 0);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved){
    switch (ul_reason_for_call){
        case DLL_PROCESS_ATTACH:
            inj_hModule = hModule; 
            HANDLE ThreadHandle = CreateThread(0, NULL, (LPTHREAD_START_ROUTINE)WindowThread, hModule, NULL, NULL);

            if (ThreadHandle != NULL) {
                CloseHandle(ThreadHandle);
            }
        break;
    }
    return TRUE;
}
</code></pre><p>I didnt write comments even tho i planed to do so.<br>I know it’s still a lot of code to throw in at once in a tutorial but i tried to keep it as simple as possible for me.<br>I have taken the comments out to not confuse you even more. That might leave some of you with questions to what some part of the code does. So if you have anything you dont understand feel free to ask about it below and i will try my best to explain it and update the thread to make it easier to understand for future readers.</p><h2 id="understanding-the-protocol"><a name="understanding-the-protocol" href="#understanding-the-protocol"></a>understanding the Protocol</h2><p>now that we have the capability to view and log unencrypted packets we need to understand the protocol of the game.<br>I actually was lucky and found the repo of somebody who already did a lot of reversing on the games protocol.<br>Repo: <a href="https://github.com/tera-proxy/tera-data/tree/master/protocol">https://github.com/tera-proxy/tera-data/tree/master/protocol</a><br>This isnt the exact protocol i have found to be used in the game but this was definetly a head start.</p><p>But what if you are not that lucky or are even the first one to reverse that game?<br>Well it is tedious work but we will go though how one would tackle this:<br>First we want to record some packets we can analyze for a specific action.<br>Since we are mostly interested in economy exploits to make us rich we will take a look at the packets that have to do with transactions first.<br>For that purpose we will deposit gold to our bank and note down the packet that was sent as well as the amount of money we deposited.<br><img src="deposit.gif" alt="deposit"><br>After some transactions we end up with a list like this:</p><pre><code data-origin="<pre><code>5g 0s 0b:    40 00 A4 D8 01 00 00 00 F8 4B CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 50 C3 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
2g 7s 3b:    40 00 A4 D8 02 00 00 00 65 4F CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 DF 50 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
1g 8s 70b:   40 00 A4 D8 03 00 00 00 24 4F CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 76 2A 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
1g 3s 1b:    40 00 A4 D8 04 00 00 00 C3 4F CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 3D 28 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
0g 50s 10b:  40 00 A4 D8 05 00 00 00 28 51 CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 92 13 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
</code></pre>">5g 0s 0b:    40 00 A4 D8 01 00 00 00 F8 4B CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 50 C3 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
2g 7s 3b:    40 00 A4 D8 02 00 00 00 65 4F CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 DF 50 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
1g 8s 70b:   40 00 A4 D8 03 00 00 00 24 4F CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 76 2A 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
1g 3s 1b:    40 00 A4 D8 04 00 00 00 C3 4F CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 3D 28 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
0g 50s 10b:  40 00 A4 D8 05 00 00 00 28 51 CF 00 79 1D 09 10 00 80 00 03 01 00 00 00 00 00 00 00 92 13 00 00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF
</code></pre><p>if you copy this list in a proper text editor you can straight away tell some obvious patterns:<br><img src="pattern.jpg" alt="pattern"></p><ul>
<li>the fith byte seems to be a sequence number that goes up by 1 for each transaction we do to or from the bank.</li><li>only the 3 bytes after the 9th byte and the 2 bytes after the 28th byte change<br>so at least one of them is related to our transaction amount.</li></ul><p>After a high level inspection we will copy a packet in a hex editor to see different representations for the data at these 2 interesting spots of the packet.<br>I use HxD for this.<br>(Get HxD here: <a href="https://mh-nexus.de/en/downloads.php?product=HxD20">https://mh-nexus.de/en/downloads.php?product=HxD20</a>)<br>(2g 7s 3b packet:)<br><img src="goldamnt.jpg" alt="goldamnt"><br>We have found out that the 28th byte does infact contain our gold amount.<br>To find out what exact datatype it is we need to find out what the other bytes in the transaction packet do.<br>After some more time reversing the packet structure i found out the packet structure looks something like this:</p><pre><code data-origin="<pre><code>struct transactionPacket{
char[4] id;
__int16 sequence;
__int16 page;
...
int64 gold;
...
};
</code></pre>">struct transactionPacket{
char[4] id;
__int16 sequence;
__int16 page;
...
int64 gold;
...
};
</code></pre><p>to confirm we found the right spot and didnt miss any checksums or anything we craft our own transaction packet with a modified amount and send it to the server:<br><img src="crafted.gif" alt="crafted"></p><h2 id="fuzzing"><a name="fuzzing" href="#fuzzing"></a>Fuzzing</h2><p>Now that we can intercept the games traffic we should think about what to target.<br>Since integer overflows appear to be acommon problem this is what we will tackle first.<br>After thinking about where they could appear some things come to mind:</p><ul>
<li>Deposit negative money</li><li>Widthdraw negative money</li><li>…</li></ul><p>This can cause interesting things to happen because databases usually store unsigned integeres where the games often work with signed integers. This is not the only problem but it seems to be a common one. So if they missed a sanity check and a negative number gets stored in the database it overflows/ gets interpreted as a really high value.</p><p>Another common thing appears to be race conditions.</p><p>Think about how you would have programed something and where there might be problems.<br>It’s also important to think out of the box well to find things that went unnoticed by others.<br>Every game is different and works differently so the flaws are different too.</p><p>Ideas to check for:</p><ul>
<li>anywhere an id gets transmitted -&gt; what happens if you change thange the id for another one?</li><li>check for logout/ save packets -&gt; If inventory doesnt get saved you can give everythig away and load the previously saved inventory from the database.</li><li>what happens when you move items to invalid slots?</li><li>sell the same item multiple times at once -&gt; check if it exists in inventory = true</li><li>delete negative items</li><li>any fees could be used to overflow an intger if sanity checks happen before fees where applied</li></ul><p>The idea with swaping the id is that games sometimes have a false trust in packets sent from the client since they encrypt everything and it also reduces the load on the server.<br>So this does not only go for ids but everything that might get trusted by the gameserver.</p><p>In this guide i didnt cover hooking the recv function of the game since it is pretty much the same as finding and hooking the send function. Also in most games the recieved packets ar not as interesting as the sent ones and you have to keep in mind that the recv function gets called constantly. That means doing alot in your hook will slow or even crahs the game. That beeing saied it can stll be interesting to see how the gameserver reacts when you send its own packets back. This could be something to try when the opcodes (first bytes) of the server and client packets are the same. Meaning they share the same protocol or language.</p><p>For this most important part of the process it’s really necessary to be patient and get into the right mindset:<br>“trying to break it”.<br>It can take weeks or even longer to find flaws and be able to exploit them.<br>But according to some talks i have heared there is pretty much always at least one exploit in any mmo that can be found using this or similar techniques.</p><p>Sources and more on that Topic:<br>Manfred Defcon Talk: <a href="https://youtu.be/QOfroRgBgo0">https://youtu.be/QOfroRgBgo0</a><br>Manfred Workflow: <a href="https://youtu.be/iYTCBPUn98c">https://youtu.be/iYTCBPUn98c</a><br>Manfred RSA Talk: <a href="https://www.rsaconference.com/industry-topics/presentation/anatomy-of-exploiting-mmorpgs">https://www.rsaconference.com/industry-topics/presentation/anatomy-of-exploiting-mmorpgs</a><br>Bot creation: <a href="https://www.youtube.com/watch?v=WMlkC5L4UZk&amp;list=PLJ3SX0ZSwtLVnZFgCwgpgPTJKF9ugpDUP">https://www.youtube.com/watch?v=WMlkC5L4UZk&amp;list=PLJ3SX0ZSwtLVnZFgCwgpgPTJKF9ugpDUP</a><br>Bot creation: <a href="https://youtu.be/T-rn6squ_E4">https://youtu.be/T-rn6squ_E4</a><br>analyzing Packets: <a href="https://progamercity.net/ghack-tut/137-tutorial-packet-hacking-reversing-mmo.html">https://progamercity.net/ghack-tut/137-tutorial-packet-hacking-reversing-mmo.html</a><br>Pwnie island writeup: <a href="https://www.youtube.com/watch?v=RDZnlcnmPUA&amp;list=PLhixgUqwRTjzzBeFSHXrw9DnQtssdAwgG">https://www.youtube.com/watch?v=RDZnlcnmPUA&amp;list=PLhixgUqwRTjzzBeFSHXrw9DnQtssdAwgG</a><br>More on reversing protocols: <a href="https://youtu.be/9pCb0vIp_kg">https://youtu.be/9pCb0vIp_kg</a><br>Mambdas Guide on packets: <a href="https://guidedhacking.com/threads/the-basics-of-packets-case-study-maplestory.14074/">https://guidedhacking.com/threads/the-basics-of-packets-case-study-maplestory.14074/</a><br>How to locate send function: <a href="https://www.elitepvpers.com/forum/metin2-guides-templates/4151499-how-locate-packetsend-function-nearly-every-game.html">https://www.elitepvpers.com/forum/metin2-guides-templates/4151499-how-locate-packetsend-function-nearly-every-game.html</a></p>
</body>
</html>
